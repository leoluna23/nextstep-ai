/**
 * app/api/plan/replan/route.ts
 *
 * POST /api/plan/replan
 *
 * Purpose:
 * - Replan ONLY the remaining (incomplete) tasks of an existing plan stored in MongoDB.
 * - Your completion model stores completed IDs in `completedTaskIds: string[]`.
 * - Therefore, we MUST preserve completed tasks (their IDs and content) to keep completion valid.
 * - We replace all remaining tasks with new tasks generated by Gemini.
 *
 * Expected body:
 * {
 *   planId: string,
 *   constraints?: string,
 *   feedback?: string
 * }
 *
 * Response:
 * {
 *   plan: Plan,               // updated plan document as source-of-truth
 *   replacedCount: number,    // number of tasks removed (remaining)
 *   newCount: number          // number of new tasks inserted
 * }
 *
 * Important:
 * - Plan structure is nested: plan.weeks[].milestones[].tasks[]
 * - Planner logic uses flattenPlan(plan) and completedTaskIds set
 * - Prereqs must not point to missing IDs. We sanitize prereqs to only reference completed IDs.
 */

import { NextResponse } from "next/server";
import { ObjectId } from "mongodb";

import clientPromise, { getDbName } from "@/lib/mongodb";
import type { Plan } from "@/models/Plan";
import { flattenPlan } from "@/lib/planner";
import { replanRemainingTasksNested } from "@/lib/gemini-replan";
import { getCurrentUser } from "@/lib/auth";

/**
 * This reflects your nested task structure (as seen in planner.ts).
 * If your Task type has additional fields, extend this type accordingly.
 */
type PlanTask = {
  id: string;
  text: string;
  minutes: number;
  category: "research" | "build" | "practice" | "network" | "apply";
  successCriteria: string;
  prereqs: string[];
};

type AiTask = {
  text: string;
  minutes: number;
  category: "research" | "build" | "practice" | "network" | "apply";
  successCriteria: string;
  prereqs?: string[];
  week?: number;
  milestoneName?: string;
};

/**
 * Generates a new unique task id.
 * These IDs must be globally unique inside the plan because completion is tracked by id string.
 */
function newTaskId(): string {
  return crypto.randomUUID();
}

/**
 * Returns a safe integer week index within [1, timelineWeeks].
 */
function clampWeek(week: any, timelineWeeks: number): number {
  const w = Number(week);
  if (!Number.isFinite(w)) return 1;
  return Math.min(Math.max(Math.round(w), 1), timelineWeeks);
}

/**
 * Ensures prereqs are safe:
 * - Only allow prereqs that reference already-completed task IDs.
 * This prevents tasks being blocked forever due to prereq IDs that no longer exist.
 */
function sanitizePrereqs(prereqs: any, completedIdSet: Set<string>): string[] {
  if (!Array.isArray(prereqs)) return [];
  return prereqs
    .map((p) => String(p).trim())
    .filter((p) => p.length > 0 && completedIdSet.has(p));
}

/**
 * Removes tasks that are NOT completed from the nested plan structure.
 * Completed tasks (id in completedTaskIds) are preserved in-place.
 * Also removes empty milestones after filtering.
 *
 * Returns:
 * - number of tasks removed (i.e., the old remaining tasks count)
 */
function removeRemainingTasksInPlace(plan: Plan, completedIdSet: Set<string>): number {
  let removed = 0;

  for (const w of plan.weeks) {
    for (const m of w.milestones) {
      const before = m.tasks.length;
      m.tasks = m.tasks.filter((t: any) => completedIdSet.has(t.id));
      removed += before - m.tasks.length;
    }
    // Remove empty milestones
    w.milestones = w.milestones.filter((m: any) => m.tasks.length > 0);
  }

  // Remove empty weeks (optional, but keeps structure clean)
  plan.weeks = plan.weeks.filter((w: any) => w.milestones.length > 0);

  return removed;
}

/**
 * Inserts a list of new tasks into the nested plan structure.
 * - Uses provided week/milestoneName when possible.
 * - Creates milestones if they don't exist.
 * - Creates weeks if they don't exist.
 */
function insertTasks(plan: Plan, newTasks: Array<{ week: number; milestoneName: string; task: PlanTask }>) {
  // Build week lookup for fast insertion
  const weekMap = new Map<number, any>();
  for (const w of plan.weeks) weekMap.set(w.week, w);

  // Ensure we have at least one week
  if (plan.weeks.length === 0) {
    plan.weeks.push({
      week: 1,
      theme: "Getting Started",
      milestones: []
    });
    weekMap.set(1, plan.weeks[0]);
  }

  for (const item of newTasks) {
    // Get or create the target week
    let targetWeek = weekMap.get(item.week);
    if (!targetWeek) {
      targetWeek = {
        week: item.week,
        theme: `Week ${item.week}`,
        milestones: []
      };
      plan.weeks.push(targetWeek);
      weekMap.set(item.week, targetWeek);
      // Sort weeks by week number
      plan.weeks.sort((a, b) => a.week - b.week);
    }

    const name = item.milestoneName;

    let milestone = targetWeek.milestones.find((mm: any) => mm.name === name);
    if (!milestone) {
      // Create new milestone with required fields matching MilestoneSchema
      milestone = { 
        id: crypto.randomUUID(),
        name, 
        why: `Milestone for replanned tasks: ${name}`,
        tasks: [] 
      };
      targetWeek.milestones.push(milestone);
    }

    milestone.tasks.push(item.task);
  }
}

export async function POST(req: Request) {
  try {
    /** Parse + validate request body */
    const body = await req.json();
    const planId = String(body.planId ?? "").trim();

    if (!planId) {
      return NextResponse.json({ error: "planId is required" }, { status: 400 });
    }

    // Optional user inputs (you can add UI for these later)
    const constraints = typeof body.constraints === "string" ? body.constraints.trim() : "";
    const feedback = typeof body.feedback === "string" ? body.feedback.trim() : "";

    /** Validate Mongo ObjectId */
    let _id: ObjectId;
    try {
      _id = new ObjectId(planId);
    } catch {
      return NextResponse.json(
        { error: "Invalid planId format (must be a Mongo ObjectId string)" },
        { status: 400 }
      );
    }

    /** Get current user and verify ownership */
    const user = await getCurrentUser();
    
    /** Load plan from Mongo */
    const client = await clientPromise;
    const db = client.db(getDbName());
    const collection = db.collection("plans");

    // Build query - verify user owns the plan if logged in
    const query: any = { _id };
    if (user) {
      query.userId = user._id;
    }

    const existing = await collection.findOne(query);
    if (!existing) {
      return NextResponse.json({ error: "Plan not found" }, { status: 404 });
    }

    const plan = existing as unknown as Plan;

    /** Completion source-of-truth */
    const completedTaskIds: string[] = Array.isArray((existing as any).completedTaskIds)
      ? (existing as any).completedTaskIds
      : [];
    const completedIdSet = new Set(completedTaskIds);

    /** Flatten plan to compute remaining tasks */
    const flat = flattenPlan(plan);
    const completedFlat = flat.filter((t) => completedIdSet.has(t.id));
    const remainingFlat = flat.filter((t) => !completedIdSet.has(t.id));

    // Nothing to replan
    if (remainingFlat.length === 0) {
      return NextResponse.json(
        { plan: existing, replacedCount: 0, newCount: 0, message: "No remaining tasks to replan." },
        { status: 200 }
      );
    }

    /**
     * Determine timelineWeeks.
     * - If you store timelineWeeks on planDoc, prefer it.
     * - Otherwise fall back to the number of weeks in the plan.
     */
    const timelineWeeks =
      Number((existing as any).timelineWeeks ?? (plan.weeks?.length ?? 6)) || 6;

    /** Goal text for Gemini context */
    const goalText = String((existing as any).goalText ?? "").trim();

    /**
     * Call Gemini to generate new remaining tasks.
     * We pass completed + remaining as context, and get back a list of AiTask.
     */
    const ai = await replanRemainingTasksNested({
      goalText,
      timelineWeeks,
      completedTasks: completedFlat.map((t) => ({
        id: t.id,
        text: t.text,
        category: t.category,
      })),
      remainingTasks: remainingFlat.map((t) => ({
        id: t.id,
        text: t.text,
        category: t.category,
      })),
      constraints,
      feedback,
    });

    if (!ai || !Array.isArray(ai.tasks)) {
      return NextResponse.json(
        { error: "Gemini returned invalid format (expected { tasks: [...] })" },
        { status: 502 }
      );
    }

    /**
     * 1) Remove old remaining tasks from nested structure
     * 2) Map AI tasks to Plan tasks (new IDs, safe prereqs)
     * 3) Insert mapped tasks into nested structure
     */
    const replacedCount = removeRemainingTasksInPlace(plan, completedIdSet);

    const mappedForInsert: Array<{ week: number; milestoneName: string; task: PlanTask }> = [];

    for (let i = 0; i < ai.tasks.length && i < 60; i++) {
      const t: AiTask = ai.tasks[i];

      // Create new task id that cannot collide with completed ids
      let id = newTaskId();
      while (completedIdSet.has(id)) id = newTaskId();

      const week = clampWeek(t.week, timelineWeeks);
      const milestoneName = String(t.milestoneName ?? "Replanned Steps").trim() || "Replanned Steps";

      const task: PlanTask = {
        id,
        text: String(t.text ?? "").trim() || "Untitled task",
        minutes: Number.isFinite(Number(t.minutes)) ? Math.max(5, Math.round(Number(t.minutes))) : 30,
        category: (["research", "build", "practice", "network", "apply"].includes(t.category)
          ? t.category
          : "build") as PlanTask["category"],
        successCriteria: String(t.successCriteria ?? "").trim() || "You can clearly verify this step is complete.",
        prereqs: sanitizePrereqs(t.prereqs, completedIdSet),
      };

      mappedForInsert.push({ week, milestoneName, task });
    }

    // Safety: ensure at least one task was created
    if (mappedForInsert.length === 0) {
      mappedForInsert.push({
        week: 1,
        milestoneName: "Replanned Steps",
        task: {
          id: newTaskId(),
          text: "Define the smallest next action for today (under 15 minutes).",
          minutes: 10,
          category: "build",
          successCriteria: "You wrote down a concrete next action and started it.",
          prereqs: [],
        },
      });
    }

    insertTasks(plan, mappedForInsert);

    /**
     * Save back to Mongo.
     * NOTE:
     * - We set the whole plan object back (plan is mutated in-place).
     * - We preserve completedTaskIds untouched.
     */
    await collection.updateOne(
      { _id },
      {
        $set: {
          ...plan,
          completedTaskIds,
          updatedAt: new Date(),
          lastReplannedAt: new Date(),
          revision: ((existing as any).revision ?? 0) + 1,
        },
      }
    );

    // Reload as source-of-truth
    const updated = await collection.findOne({ _id });

    return NextResponse.json(
      {
        plan: updated,
        replacedCount,
        newCount: mappedForInsert.length,
      },
      { status: 200 }
    );
  } catch (err: any) {
    console.error("REPLAN error:", err);
    return NextResponse.json({ error: err?.message ?? "Failed to replan" }, { status: 500 });
  }
}
